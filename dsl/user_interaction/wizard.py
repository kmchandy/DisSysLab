"""
DisSysLab Wizard — Milestone A
- Top menu + Step 1 (Quick Build) + Step 2 (Messages as Dicts)
- Emits chapter-style code to build/network.py
- Runs core.check() before writing the file
"""

from __future__ import annotations

import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Tuple, Any, Optional

# Optional structural check (safe if not available)
try:
    from dsl.core import check as core_check
except Exception:
    core_check = None  # type: ignore[assignment]

# ----- Utilities


def ask(prompt: str, valid: Optional[List[str]] = None) -> str:
    while True:
        ans = input(prompt).strip()
        if not valid or ans in valid:
            return ans
        print("Please enter one of: " + ", ".join(valid))


def write_textfile(path: str, text: str) -> None:
    p = Path(path)
    p.parent.mkdir(parents=True, exist_ok=True)
    p.write_text(text)


def structural_check(names: List[str], conns: List[Tuple[str, str, str, str]]) -> bool:
    if core_check is None:
        return True
    try:
        res = core_check(set(names), conns)
        if isinstance(res, tuple) and len(res) == 2:
            ok, msgs = bool(res[0]), list(res[1])
            if not ok:
                print("❌ Structural check failed:")
                for m in msgs:
                    print("  - " + str(m))
                return False
        return True
    except Exception as e:
        print("❌ Structural check error: " + str(e))
        return False

# ----- Choices (Step 1 / Step 2)


FEEDS: List[Tuple[str, str]] = [
    ("1", "https://www.espn.com/espn/rss/news"),  # ESPN
    ("2", "https://feeds.bbci.co.uk/news/rss.xml"),  # BBC
    ("3", "https://rss.nytimes.com/services/xml/rss/nyt/Technology.xml"),  # NYT Tech
    ("4", "https://news.ycombinator.com/rss"),  # Hacker News
]
FEED_LABELS: Dict[str, str] = {
    "1": "ESPN Sports",
    "2": "BBC World News",
    "3": "NYT Technology",
    "4": "Hacker News",
}

TRANSFORMERS: Dict[str, str] = {
    "1": "SentimentTransformer",
    "2": "EntityExtractor",
}
TRANSFORMER_LABELS: Dict[str, str] = {
    "1": "Sentiment Analysis",
    "2": "Entity Extraction",
}

RECORDERS: Dict[str, Tuple[str, Dict[str, Any]]] = {
    "1": ("RecordToConsole", {}),
    "2": ("RecordToFile", {"path": "results.txt"}),
}
REC_LABELS: Dict[str, str] = {
    "1": "Print to console",
    "2": "Save to file",
}

# ----- Code generation (chapter style)


def emit_chapter_style_pipeline(feed_url: str, xform_cls: str, rec_cls: str, rec_kwargs: Dict[str, Any]) -> str:
    """
    Build chapter-style Python code as lines and join.
    Avoid multi-line string literals to prevent unterminated-string issues.
    """
    lines: List[str] = []
    lines.append("# Generated by DisSysLab Wizard — Step 1/2 (Pipeline)")
    lines.append("from dsl.core import Network")
    lines.append("from dsl.block_lib.stream_generators import GenerateFromRSS")
    # Import the selected transformer and recorder
    if xform_cls == "SentimentTransformer":
        lines.append(
            "from dsl.block_lib.stream_transformers import SentimentTransformer")
    else:
        lines.append(
            "from dsl.block_lib.stream_transformers import EntityExtractor")
    if rec_cls == "RecordToConsole":
        lines.append(
            "from dsl.block_lib.stream_recorders import RecordToConsole")
    else:
        lines.append("from dsl.block_lib.stream_recorders import RecordToFile")
    lines.append("")
    lines.append("# Define the network: blocks and connections")
    lines.append("net = Network(")
    lines.append("    blocks={")
    lines.append(f"        \"rss_gen\": GenerateFromRSS(url={feed_url!r}),")
    if xform_cls == "SentimentTransformer":
        lines.append("        \"xform\":   SentimentTransformer(),")
    else:
        lines.append("        \"xform\":   EntityExtractor(),")
    if rec_cls == "RecordToConsole":
        lines.append("        \"sink\":    RecordToConsole(),")
    else:
        arg = f"path={rec_kwargs.get('path', 'results.txt')!r}"
        lines.append(f"        \"sink\":    RecordToFile({arg}),")
    lines.append("    },")
    lines.append("    connections=[")
    lines.append("        (\"rss_gen\", \"out\", \"xform\", \"in\"),")
    lines.append("        (\"xform\",   \"out\", \"sink\",  \"in\"),")
    lines.append("    ]")
    lines.append(")")
    lines.append("")
    lines.append("# Run the network")
    lines.append("net.compile_and_run()")
    lines.append("")
    return "\n".join(lines)

# ----- Steps


def do_step1() -> int:
    # Intro for Step 1
    print()
    print("⚡ Quick Build — Pipeline (News + NLP)")
    print("This app streams headlines, analyzes them, and shows results continuously.")
    print()

    # Feed choice
    print("Step 1 — Pick a news feed:")
    print("  [1] ESPN Sports")
    print("  [2] BBC World News")
    print("  [3] New York Times Technology")
    print("  [4] Hacker News")
    feed_key = ask("Select 1-4: ", ["1", "2", "3", "4"])
    feed_url = dict(FEEDS)[feed_key]
    print("  → Feed: " + FEED_LABELS[feed_key])

    # Transformer choice
    print()
    print("Step 2 — How should we analyze each headline?")
    print("  [1] Sentiment Analysis (positive / negative / neutral)")
    print("  [2] Entity Extraction (find people / places)")
    x_key = ask("Select 1-2: ", ["1", "2"])
    xform_cls = TRANSFORMERS[x_key]
    print("  → Transformer: " + TRANSFORMER_LABELS[x_key])

    # Recorder choice
    print()
    print("Step 3 — Where should results go?")
    print("  [1] Print to console")
    print("  [2] Save to file")
    r_key = ask("Select 1-2: ", ["1", "2"])
    rec_cls, rec_kwargs = RECORDERS[r_key]
    print("  → Recorder: " + REC_LABELS[r_key])

    # Structural check
    names = ["rss_gen", "xform", "sink"]
    conns = [
        ("rss_gen", "out", "xform", "in"),
        ("xform", "out", "sink", "in"),
    ]
    if not structural_check(names, conns):
        return 1

    # Emit file
    code = emit_chapter_style_pipeline(
        feed_url, xform_cls, rec_cls, rec_kwargs)
    outfile = "build/network.py"
    write_textfile(outfile, code)
    print()
    print("✅ Saved:", outfile)
    print("▶️ Next: python", outfile)
    print()
    return 0


def do_step2() -> int:
    # Step 2 focuses on dict messages; we pin the transformer to Sentiment
    print()
    print("🧩 Messages as Dicts — same pipeline, with enriched output")
    print("Each message is a Python dict. The transformer adds a 'sentiment' field.")
    print()

    # Feed choice (keep it simple)
    print("Pick a business/news feed:")
    print("  [1] BBC World News")
    print("  [2] Reuters Business (enter 2 for a custom URL later if you add it)")
    print("  [3] ESPN Sports")
    print("  [4] Hacker News")
    feed_key = ask("Select 1-4: ", ["1", "2", "3", "4"])
    feed_url = dict(FEEDS)[feed_key]
    print("  → Feed:", FEED_LABELS[feed_key])

    # Recorder choice
    print()
    print("Where should results go?")
    print("  [1] Print to console (recommended for this step)")
    print("  [2] Save to file")
    r_key = ask("Select 1-2: ", ["1", "2"])
    rec_cls, rec_kwargs = RECORDERS[r_key]
    print("  → Recorder:", REC_LABELS[r_key])

    # Structural check
    names = ["rss_gen", "xform", "sink"]
    conns = [
        ("rss_gen", "out", "xform", "in"),
        ("xform", "out", "sink", "in"),
    ]
    if not structural_check(names, conns):
        return 1

    # Emit file with SENTIMENT transformer to encourage dict output {"text", "sentiment"}
    code = emit_chapter_style_pipeline(
        feed_url, "SentimentTransformer", rec_cls, rec_kwargs)
    outfile = "build/network.py"
    write_textfile(outfile, code)
    print()
    print("✅ Saved:", outfile)
    print("▶️ Next: python", outfile)
    print()
    return 0

# ----- Main menu


def main() -> int:
    print()
    print("Welcome to DisSysLab Wizard!")
    print("Unlike normal programs that run once and stop,")
    print("distributed apps keep running — listening for new data and producing results continuously.")
    print("Press Ctrl+C anytime to stop an app.")
    print()

    while True:
        print("What would you like to do?")
        print("  [1] Quick Build (News + NLP)")
        print("  [2] Messages as Dicts")
        print("  [3] Quit")
        choice = ask("Select 1-3: ", ["1", "2", "3"])
        if choice == "1":
            rc = do_step1()
            if rc != 0:
                return rc
        elif choice == "2":
            rc = do_step2()
            if rc != 0:
                return rc
        else:
            print("Goodbye!")
            return 0


if __name__ == "__main__":
    sys.exit(main())
