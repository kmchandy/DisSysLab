from __future__ import annotations
from dataclasses import dataclass, field
from typing import Dict, List, Tuple, Callable, Any, Optional

# ----- Types
# name -> class name (e.g., "rss_gen": "RSSGenerator")
Blocks = Dict[str, str]
Kwargs = Dict[str, Any]              # per block kwargs
Connections = List[Tuple[str, str, str, str]]  # (src, out, dst, in)


@dataclass
class NetworkSpec:
    blocks: Blocks                    # class names, not instances
    kwargs: Dict[str, Kwargs]         # block_name -> kwargs
    connections: Connections


@dataclass
class CodeBundle:
    filename: str
    code: str
    run_hint: str = "python build/network.py"


@dataclass
class Choice:
    key: str
    label: str
    value: Any


@dataclass
class Lesson:
    id: str
    title: str
    summary: str
    topology: str                      # "pipeline" | "fanin" | "fanout"
    # Prompt -> options
    menus: List[Tuple[str, List[Choice]]]
    # Given user selections, produce a spec and code
    build: Callable[[Dict[str, Any]], Tuple[NetworkSpec, CodeBundle]]


# ----- Shared menus (so Step 1 & 2 reuse)
FEEDS = [
    Choice("espn", "ESPN Sports", "https://www.espn.com/espn/rss/news"),
    Choice("bbc",  "BBC World News", "https://feeds.bbci.co.uk/news/rss.xml"),
    Choice("nyt",  "NYT Technology",
           "https://rss.nytimes.com/services/xml/rss/nyt/Technology.xml"),
    Choice("hn",   "Hacker News", "https://news.ycombinator.com/rss"),
]

TRANSFORMERS_STEP1 = [
    Choice("sent", "Sentiment Analysis", "SentimentTransformer"),
    Choice("ents", "Entity Extraction",  "EntityExtractor"),
]

RECORDERS_BASIC = [
    Choice("console", "Print to console", ("RecordToConsole", {})),
    Choice("file",    "Save to file",
           ("RecordToFile",   {"path": "results.txt"})),
]

# ----- Lesson builders


def build_step1(ctx: Dict[str, Any]) -> Tuple[NetworkSpec, CodeBundle]:
    feed_url: str = ctx["feed_url"]
    # "SentimentTransformer" | "EntityExtractor"
    xform_cls: str = ctx["xform_cls"]
    rec_cls, rec_kwargs = ctx["rec"]

    blocks = {
        "rss_gen": "RSSGenerator",
        "xform":   xform_cls,
        "sink":    rec_cls,
    }
    kwargs = {
        "rss_gen": {"url": feed_url},
        "xform":   {},
        "sink":    rec_kwargs,
    }
    connections = [
        ("rss_gen", "out", "xform", "in"),
        ("xform", "out", "sink", "in"),
    ]
    spec = NetworkSpec(blocks=blocks, kwargs=kwargs, connections=connections)

    code = f'''# Generated by Wizard — Step 1 (Pipeline)
from dsl.core import Network
from dsl.block_lib.stream_generators import RSSGenerator
from dsl.block_lib.stream_transformers import {xform_cls}
from dsl.block_lib.stream_recorders import {rec_cls}

net = Network(
    blocks={{
        "rss_gen": RSSGenerator(url="{feed_url}"),
        "xform":   {xform_cls}(),
        "sink":    {rec_cls}({", ".join(f"{k}={repr(v)}" for k, v in rec_kwargs.items())}),
    }},
    connections=[
        ("rss_gen", "out", "xform", "in"),
        ("xform", "out", "sink", "in"),
    ]
)
net.compile_and_run()
'''
    bundle = CodeBundle(filename="build/network.py", code=code)
    return spec, bundle


def build_step2_dicts(ctx: Dict[str, Any]) -> Tuple[NetworkSpec, CodeBundle]:
    # Fixed: Sentiment + dict output w/ "text" and "sentiment"
    feed_url: str = ctx["feed_url"]
    rec_cls, rec_kwargs = ctx["rec"]

    blocks = {
        "rss_gen": "RSSGenerator",
        "sentiment": "SentimentTransformer",
        "sink": rec_cls,
    }
    kwargs = {
        "rss_gen": {"url": feed_url},
        "sentiment": {},
        "sink": rec_kwargs,
    }
    connections = [
        ("rss_gen", "out", "sentiment", "in"),
        ("sentiment", "out", "sink", "in"),
    ]
    spec = NetworkSpec(blocks=blocks, kwargs=kwargs, connections=connections)

    code = f'''# Generated by Wizard — Step 2 (Messages as Dicts)
from dsl.core import Network
from dsl.block_lib.stream_generators import RSSGenerator
from dsl.block_lib.stream_transformers import SentimentTransformer
from dsl.block_lib.stream_recorders import {rec_cls}

net = Network(
    blocks={{
        "rss_gen": RSSGenerator(url="{feed_url}"),
        "sentiment": SentimentTransformer(),
        "sink": {rec_cls}({", ".join(f"{k}={repr(v)}" for k, v in rec_kwargs.items())}),
    }},
    connections=[
        ("rss_gen", "out", "sentiment", "in"),
        ("sentiment", "out", "sink", "in"),
    ]
)
net.compile_and_run()
'''
    bundle = CodeBundle(filename="build/network.py", code=code)
    return spec, bundle

# ----- Lesson registry


LESSONS: Dict[str, Lesson] = {
    "step1": Lesson(
        id="step1",
        title="Pipeline: News + NLP",
        summary="Build a simple pipeline: RSS → Transformer → Recorder.",
        topology="pipeline",
        menus=[
            ("Pick a news feed", FEEDS),
            ("Pick an analysis", TRANSFORMERS_STEP1),
            ("Where should results go?", RECORDERS_BASIC),
        ],
        build=build_step1,
    ),
    "step2_dicts": Lesson(
        id="step2_dicts",
        title="Messages as Dicts",
        summary="See message enrichment: transformer adds 'sentiment' to the message dict.",
        topology="pipeline",
        menus=[
            ("Pick a news feed", FEEDS),
            ("Where should results go?", RECORDERS_BASIC),
        ],
        build=build_step2_dicts,
    ),
}


def get_lesson(lesson_id: str) -> Optional[Lesson]:
    return LESSONS.get(lesson_id)
