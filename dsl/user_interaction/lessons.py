# dsl/user_interaction/lessons.py  (kit-based)
from __future__ import annotations
from dataclasses import dataclass
from typing import Dict, List, Tuple, Callable, Any, Optional

# ----- Types
# name -> kit class name (e.g., "rss": "FromRSS")
Blocks = Dict[str, str]
Kwargs = Dict[str, Any]                        # per block kwargs
Connections = List[Tuple[str, str, str, str]]  # (src, out, dst, in)


@dataclass
class NetworkSpec:
    blocks: Blocks                    # class names (strings), not instances
    kwargs: Dict[str, Kwargs]         # block_name -> kwargs
    connections: Connections


@dataclass
class CodeBundle:
    filename: str
    code: str
    run_hint: str = "python build/network.py"


@dataclass
class Choice:
    key: str
    label: str
    value: Any


@dataclass
class Lesson:
    id: str
    title: str
    summary: str
    topology: str                      # "pipeline" | "fanin" | "fanout"
    menus: List[Tuple[str, List[Choice]]]
    build: Callable[[Dict[str, Any]], Tuple[NetworkSpec, CodeBundle]]


# ==============================
# Shared menus (kit-based)
# ==============================

FEEDS = [
    Choice("espn", "ESPN Sports", "https://www.espn.com/espn/rss/news"),
    Choice("bbc",  "BBC World News", "https://feeds.bbci.co.uk/news/rss.xml"),
    Choice("nyt",  "NYT Technology",
           "https://rss.nytimes.com/services/xml/rss/nyt/Technology.xml"),
    Choice("hn",   "Hacker News", "https://news.ycombinator.com/rss"),
]

# Beginner-friendly transforms: clear verbs
TRANSFORMS_STEP1 = [
    Choice("add_sent", "Add Sentiment (annotate)",
           "AddSentiment"),   # adds 'sentiment' field
    Choice("upper",    "Uppercase text",
           "Uppercase"),      # simple, visual
    # You can add more later: ExtractEntities, SelectKeys, etc.
]

# Sinks: prefer console or JSONL for simple wins
RECORDERS_BASIC = [
    Choice("console", "Print to Console", ("ToConsole", {})),
    Choice("jsonl",   "Save to JSONL",
           ("ToJSONL", {"path": "results.jsonl"})),
    Choice("file",    "Save plain text",
           ("ToFile",  {"path": "results.txt"})),
]


# ==============================
# Lesson builders (kit-based)
# ==============================

def _kwargs_str(kwargs: Dict[str, Any]) -> str:
    """Render kwargs into a Python arg string: key1=..., key2=..."""
    if not kwargs:
        return ""
    parts = []
    for k, v in kwargs.items():
        parts.append(f"{k}={repr(v)}")
    return ", " + ", ".join(parts)


def build_step1(ctx: Dict[str, Any]) -> Tuple[NetworkSpec, CodeBundle]:
    """
    Pipeline: FromRSS -> Transform (student picks) -> Sink (console/file)
    Generates kit code using pipeline([...]).
    """
    feed_url: str = ctx["feed_url"]               # selected FEEDS value
    # "AddSentiment" | "Uppercase"
    xform_cls: str = ctx["xform_cls"]
    # e.g., ("ToConsole", {}) or ("ToJSONL", {"path": ...})
    rec_cls, rec_kwargs = ctx["rec"]

    blocks = {
        "rss": "FromRSS",
        "xform": xform_cls,
        "sink": rec_cls,
    }
    kwargs: Dict[str, Kwargs] = {
        "rss": {"url": feed_url},
        "xform": {},
        "sink": rec_kwargs,
    }
    connections: Connections = [
        ("rss", "out", "xform", "in"),
        ("xform", "out", "sink", "in"),
    ]

    spec = NetworkSpec(blocks=blocks, kwargs=kwargs, connections=connections)

    # ---- kit code (pipeline) ----
    # Import only what we actually need (nice for students)
    imports = {
        "FromRSS": True,
        xform_cls: True,
        rec_cls: True,
        "pipeline": True,
    }
    import_names = ", ".join([name for name, on in imports.items() if on])

    code = f'''# Generated by Wizard — Step 1 (Pipeline, kit)
from dsl.kit import {import_names}

net = pipeline([
    FromRSS(url={feed_url!r}),
    {xform_cls}(),
    {rec_cls}({_kwargs_str(rec_kwargs)[2:] if rec_kwargs else ""})
])

net.compile_and_run()
'''
    bundle = CodeBundle(filename="build/network.py", code=code)
    return spec, bundle


def build_step2_dicts(ctx: Dict[str, Any]) -> Tuple[NetworkSpec, CodeBundle]:
    """
    Messages as dicts: FromRSS -> AddSentiment (annotate) -> Sink
    """
    feed_url: str = ctx["feed_url"]
    rec_cls, rec_kwargs = ctx["rec"]

    blocks = {
        "rss": "FromRSS",
        "sentiment": "AddSentiment",
        "sink": rec_cls,
    }
    kwargs: Dict[str, Kwargs] = {
        "rss": {"url": feed_url},
        "sentiment": {},
        "sink": rec_kwargs,
    }
    connections: Connections = [
        ("rss", "out", "sentiment", "in"),
        ("sentiment", "out", "sink", "in"),
    ]
    spec = NetworkSpec(blocks=blocks, kwargs=kwargs, connections=connections)

    code = f'''# Generated by Wizard — Step 2 (Messages as Dicts, kit)
from dsl.kit import FromRSS, AddSentiment, {rec_cls}, pipeline

net = pipeline([
    FromRSS(url={feed_url!r}),
    AddSentiment(),          # adds 'sentiment' to each message dict
    {rec_cls}({_kwargs_str(rec_kwargs)[2:] if rec_kwargs else ""})
])

net.compile_and_run()
'''
    bundle = CodeBundle(filename="build/network.py", code=code)
    return spec, bundle


# ==============================
# Lesson registry
# ==============================

LESSONS: Dict[str, Lesson] = {
    "step1": Lesson(
        id="step1",
        title="Pipeline: News + Analysis",
        summary="Build a simple pipeline: RSS → Transform → Sink (console/file).",
        topology="pipeline",
        menus=[
            ("Pick a news feed", FEEDS),
            ("Pick an analysis", TRANSFORMS_STEP1),
            ("Where should results go?", RECORDERS_BASIC),
        ],
        build=build_step1,
    ),
    "step2_dicts": Lesson(
        id="step2_dicts",
        title="Messages as Dicts (Annotate)",
        summary="See enrichment: Add 'sentiment' to each message dict.",
        topology="pipeline",
        menus=[
            ("Pick a news feed", FEEDS),
            ("Where should results go?", RECORDERS_BASIC),
        ],
        build=build_step2_dicts,
    ),
}


def get_lesson(lesson_id: str) -> Optional[Lesson]:
    return LESSONS.get(lesson_id)
